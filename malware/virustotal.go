package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"os"
	"time"

	"github.com/tealeg/xlsx"
)

//e43514f8f764158232856f1675b2224bc4b4e33f3695d2e2996a070c5f55cd3d

//daff0380586bc26680da5ab686f902781fdbc3ccbe3c75174076e7ecc9a47346
var dir, excel string

var size int

type det struct {
	Detected bool `json:"detected"`
}
type Scans struct {
	Scan map[string]det `json:"scans"`
}

func getResoucre(path string) string {
	fmt.Println("geting resource for " + path)
	url := "https://www.virustotal.com/vtapi/v2/file/scan"
	method := "POST"

	payload := &bytes.Buffer{}
	writer := multipart.NewWriter(payload)
	_ = writer.WriteField("apikey", "e43514f8f764158232856f1675b2224bc4b4e33f3695d2e2996a070c5f55cd3d")
	file, errFile2 := os.Open(path)
	defer file.Close()
	part2,
		errFile2 := writer.CreateFormFile("file", path)
	_, errFile2 = io.Copy(part2, file)
	if errFile2 != nil {
		panic("error conpy file :" + errFile2.Error())
	}
	err := writer.Close()
	if err != nil {
		panic("error write close" + err.Error())
	}

	client := &http.Client{}
	req, err := http.NewRequest(method, url, payload)

	if err != nil {
		panic("error request : " + err.Error())
	}

	req.Header.Set("Content-Type", writer.FormDataContentType())
	res, err := client.Do(req)
	if err != nil {
		panic("error do request : " + err.Error())
	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		panic("error read body " + err.Error())
	}
	type resp struct {
		Resource string `json:"resource"`
	}

	tmp := new(resp)

	if err := json.Unmarshal(body, tmp); err != nil {
		fmt.Println(string(body))

		panic("error unmarshal : " + err.Error())
	}
	fmt.Println("get resource is done")
	return tmp.Resource
}

func init() {
	flag.StringVar(&dir, "dir", "", "")
	flag.StringVar(&excel, "excel", "", "")
	flag.IntVar(&size, "size", 0, "")
}

func main() {
	flag.Parse()

	xfile, err := xlsx.OpenFile(excel)
	if err != nil {
		panic(err)
	}

	sh := xfile.Sheets[0]
	// drweb := 0
	// avira := 0
	// comodo := 0
	// fsecure := 0
	// escan := 0
	// clamav := 0
	// windows := 0
	drweb, err := sh.Cell(1, 15).Int()
	if err != nil {
		panic("erro count dr web" + err.Error())
	}
	avira, err := sh.Cell(1, 20).Int()
	if err != nil {
		panic("avira" + err.Error())
	}
	comodo, err := sh.Cell(1, 16).Int()
	if err != nil {
		panic("comodo" + err.Error())
	}
	fsecure, err := sh.Cell(1, 18).Int()
	if err != nil {
		panic("fsecure" + err.Error())
	}
	escan, err := sh.Cell(1, 17).Int()
	if err != nil {
		panic("escan" + err.Error())
	}
	clamav, err := sh.Cell(1, 19).Int()
	if err != nil {
		panic("clamav" + err.Error())
	}
	windows, err := sh.Cell(1, 21).Int()
	if err != nil {
		panic("windows" + err.Error())
	}

	files, err := ioutil.ReadDir(dir)

	if err != nil {
		panic("error read dir :" + err.Error())
	}
	for i, file := range files {
		if file.IsDir() {
			fmt.Println(i+1, " of ", len(files), " is dir .")
			continue
		}
		if i > size-1 {
			break
		}

		if i < 338 {
			continue
		}
		resource := getResoucre(dir + "/" + file.Name())
		fmt.Println("sleep 25 sec")
		time.Sleep(25 * time.Second)

		resp := getResp(resource)

		fmt.Println(resp)
		count := 0

		for key, value := range resp.Scan {
			switch key {
			case "F-Secure":
				fmt.Println("f-secure")
				fmt.Println(value.Detected)

				cell := sh.Cell(i+2, 18)
				if value.Detected {
					fsecure++
					count++
				}
				cell.SetValue(parse(value.Detected))
				break
			case "DrWeb":
				fmt.Println("drweb")
				cell := sh.Cell(i+2, 15)
				cell.SetValue(parse(value.Detected))
				if value.Detected {
					drweb++
					count++

				}
				fmt.Println(value.Detected)
				break

			case "Avira":
				fmt.Println("avira")
				fmt.Println(value.Detected)
				cell := sh.Cell(i+2, 20)
				cell.SetValue(parse(value.Detected))
				if value.Detected {
					avira++
					count++

				}
				break
			case "ClamAV":
				fmt.Println("clamav")
				fmt.Println(value.Detected)
				cell := sh.Cell(i+2, 19)
				cell.SetValue(parse(value.Detected))
				if value.Detected {
					clamav++
					count++

				}
				break
			case "MicroWorld-eScan":
				fmt.Println("escan")
				cell := sh.Cell(i+2, 17)
				cell.SetValue(parse(value.Detected))
				fmt.Println(value.Detected)
				if value.Detected {
					escan++
					count++

				}
				break
			case "Comodo":
				fmt.Println("comodo")
				cell := sh.Cell(i+2, 16)
				cell.SetValue(parse(value.Detected))
				fmt.Println(value.Detected)
				if value.Detected {
					comodo++
					count++

				}

			case "Microsoft":
				fmt.Println("Microsoft")
				cell := sh.Cell(i+2, 21)
				cell.SetValue(parse(value.Detected))
				fmt.Println(value.Detected)
				if value.Detected {
					windows++
					count++

				}
				break
				// default:
				// 	fmt.Println(fmt.Println(key))
			}

		}
		cell := sh.Cell(i+2, 14)
		cell.SetValue(fmt.Sprint(count, "/7"))
		cell = sh.Cell(1, 18)
		cell.SetValue(fsecure)

		cell = sh.Cell(1, 19)
		cell.SetValue(clamav)

		cell = sh.Cell(1, 20)
		cell.SetValue(avira)

		cell = sh.Cell(1, 21)
		cell.SetValue(windows)

		cell = sh.Cell(1, 17)
		cell.SetValue(escan)

		cell = sh.Cell(1, 16)
		cell.SetValue(comodo)

		cell = sh.Cell(1, 15)
		cell.SetValue(drweb)
		fmt.Println("done", i+1)

		if err := xfile.Save(excel); err != nil {
			panic(err)
		}
		fmt.Println("sleep 10 s")
		time.Sleep(10 * time.Second)
	}

	if err := xfile.Save(excel); err != nil {
		panic(err)
	}

}

func getResp(resource string) *Scans {
	fmt.Println("getting resp for resource " + resource)
	url := "https://www.virustotal.com/vtapi/v2/file/report?apikey=e43514f8f764158232856f1675b2224bc4b4e33f3695d2e2996a070c5f55cd3d&resource=" + resource
	method := "GET"

	client := &http.Client{}
	req, err := http.NewRequest(method, url, nil)

	if err != nil {
		panic("error request : " + err.Error())
	}

	res, err := client.Do(req)
	if err != nil {
		panic("error do request : " + err.Error())
	}

	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		panic("error read body " + err.Error())
	}

	if res.StatusCode != 200 {
		fmt.Println(res.StatusCode)
		panic(string(body))
	}

	resp1 := new(Scans)
	if err := json.Unmarshal(body, resp1); err != nil {
		fmt.Println(string(body))

		panic("error unmarshal :" + err.Error())
	}
	fmt.Println("get resp is done")

	return resp1
}

func parse(in bool) int {
	if in {
		return 1
	}
	return 0
}
